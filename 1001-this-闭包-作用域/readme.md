## this

#### 程序是怎么运行的
传统来说，编译是一件很复杂的事情。
`QString str = "hello"`;
1. 先进行分词。
QString / str / = / "hello" /

2. 构建 AST（抽象语法树）
给你反推出来，这句话的意思。

3. 代码生成
最后，转换成为一段可以执行的机器指令。

### 对 JS 来说，主要分为两个阶段
- 预编译阶段  这个时候，由编译器，将 JS 编译成可执行的代码
  - 进行变量声明
  - 进行变量提升，但其值是 undefined
  - 所有非表达式的函数声明，进行提升

- 代码执行阶段


### 有三个角色

#### 编译器
#### 执行引擎
#### 作用域

`var a = 2`

- `var a`
编译器先去问作用域，是不是已经有了一个a，在当前的作用域中？
  作用域：是：编译器就会忽略这个声明，然后继续往下走；
       不是：编译器会在当前的作用域中，产生成一个新的变量，命名为 a；
  
  然后，生成 `a = 2` 这句话所能够被殷勤执行的代码；

runtime
引擎在执行时，会问作用域，是不是已经有一个 a，在当前作用域中？
      如果是：赋值为 2
     如果不是：去**上一层的作用域**中去找

如果找到了，就直接赋值为2，如果没找到，引擎就会抛出一个异常

### 作用域
> 作用域，就是根据名称，去查找变量的规则

#### 词法作用域 / 静态作用域
词法作用域，就是定义在，词法阶段的作用域

#### 动态作用域 / 上下文
在运行时的作用域。

#### 什么情况下，我的上下文 和 作用域不一致呢？
闭包的时候

#### 如何去解释闭包

### 上下文

上下文是如何确定的？

#### this

##### this 到底指向什么？
this 的指向，是根据我的执行上下文，动态决定的。
- 在简单调用时，this 默认指向的是 window / global / undefined（浏览器/node/严格模式）
- 在对象调用时，绑定在对象上
- 在使用 call / apply / bind 时，绑定在指定的参数上
- 在使用 new 关键字时，绑定到新创建的对象上
（以上三条优先级： new > apply/call/bind > 对象调用）
- 使用箭头函数，根据外层的规则确定。


##### 手写一个 bind / call

```js

```


#### 补充

浏览器的本质：
渲染 html + css , --- DOM,  DOM ---  执行JS，JS 引擎（宿主环境，给你提供全局对象）

node 、浏览器是两个环境。（宿主环境，给你提供全局对象）

##### 应用场景
##### 思考题
在考虑 new 的优先级，比 bind 高的时候，这个 bind 的实现应该怎么改？